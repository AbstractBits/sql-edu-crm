-- EXTENSIONS

create extension "pgcrypto";

-- CUSTOM TYPES

create type gender as enum ('M', 'F');

-- TABLES

create table if not exists countries (
	country_id int generated by default as identity primary key,
	country_name character varying(40) not null
);

create table if not exists states (
	state_id int generated by default as identity primary key,
	state_name character varying(40) not null,
	country_id int not null references countries(country_id)
);

create table if not exists users (
	user_id int generated by default as identity primary key,
	user_username character varying(40) not null,
	user_password character varying(60) not null,
	user_firstname character varying(20) not null,
	user_lastname character varying(20) not null,
	user_gender gender not null,
	user_birthday date not null,
	state_id int not null references states(state_id),
	user_is_active boolean default true,
	user_created_at timestamp with time zone default current_timestamp
);

create unique index username_idx on users (lower(user_username));

create table if not exists permissions (
	permission_id int generated by default as identity primary key,
	permission_action smallint not null,
	user_id int not null references users(user_id)
);

create table if not exists accounts (
	account_id int generated by default as identity primary key,
	account_balance decimal(15, 2) default 0,
	user_id int not null references users(user_id)
);

create table if not exists deposits (
	deposit_id int generated by default as identity primary key,
	deposit_amount decimal(15, 2) default 0,
	deposit_time timestamp with time zone default current_timestamp,
	account_id int not null references accounts(account_id),
	user_id int not null references users(user_id)
);

create table if not exists transfers (
	transfer_id int generated by default as identity primary key,
	transfer_amount decimal(15, 2) not null,
	transfer_time timestamp with time zone default current_timestamp,
	sender_id int not null references accounts(account_id),
	receiver_id int not null references accounts(account_id)
);

create table if not exists branches (
	branch_id int generated by default as identity primary key,
	branch_name character varying(64) not null
);

create table if not exists courses (
	course_id int generated by default as identity primary key,
	course_name character varying(64) not null
);

create unique index coursename_idx on courses (lower(course_name));

create table if not exists groups (
	group_id int generated by default as identity primary key,
	group_lessons smallint not null,
	group_price decimal(15, 2) not null,
	group_completed_at timestamp with time zone null,
	group_completed_lessons smallint default 0,
	course_id int not null references courses(course_id),
	branch_id int not null references branches(branch_id),
	user_id int not null references users (user_id)
);

create table if not exists lessons (
	lesson_id int generated by default as identity primary key,
	lesson_started_at timestamp with time zone default current_timestamp,
	lesson_finished_at timestamp with time zone null,
	group_id int not null references groups(group_id)
);

create table if not exists quotas (
	quota_id int generated by default as identity primary key,
	quota_raise smallint not null,
	group_id int not null references groups(group_id)
);

create table if not exists participants (
	participant_id int generated by default as identity primary key,
	participant_role smallint not null,
	participant_initial_lesson smallint default 0,
	participant_discount smallint null,
	quota_id int null references quotas(quota_id),
	group_id int not null references groups(group_id),
	user_id int not null references users(user_id)
);

create table if not exists group_transfers (
	group_transfer_id int generated by default as identity primary key,
	group_transfer_type smallint not null,
	lesson_count smallint not null,
	lesson_id int not null references lessons(lesson_id),
	participant_id int not null references participants(participant_id)
);

create table if not exists group_payments (
	group_payment_id int generated by default as identity primary key,
	transfer_id int not null references transfers(transfer_id),
	group_id int not null references groups(group_id)
);

-- TRIGGERS

create or replace function insert_after_deposits_fn() returns trigger language plpgsql as $$
	begin
		update accounts set
		account_balance = account_balance + new.deposit_amount
		where account_id = new.account_id;
		return new;
	end;
$$;

create trigger insert_after_deposits
after insert on deposits for each row
execute procedure insert_after_deposits_fn()
;

create or replace function insert_after_transfers_fn() returns trigger language plpgsql as $$
	begin
		update accounts set
		account_balance = account_balance - new.transfer_amount
		where account_id = new.sender_id;
		return new;
	end;
$$;

create trigger insert_after_transfers
after insert on transfers for each row
execute procedure insert_after_transfers_fn()
;

create or replace function insert_after_users_fn() returns trigger language plpgsql as $$
	begin
		insert into accounts(user_id) values (new.user_id);
		return new;
	end;
$$;

create trigger insert_after_users
after insert on users for each row
execute procedure insert_after_users_fn()
;

-- FUNCTIONS

drop function if exists deposit;
create or replace function deposit (
	operator int,
	account int,
	amount decimal(15, 2)
) returns table (
	deposit_id int,
	deposit_amount decimal(15, 2),
	deposit_time timestamp with time zone,
	account_id int,
	user_id int
) language plpgsql as $$
	declare
		current_deposit deposits%rowtype;
	begin
		if
			(
				select
					p.permission_id
				from
					permissions as p
				where
					p.user_id = operator and
					p.permission_action = 2
			)
			is not null
		then
			insert into deposits (deposit_amount, account_id, user_id)
			values (amount, account, operator)
			returning * into current_deposit;
			return query select *
			from deposits
			where deposits.deposit_id = current_deposit.deposit_id;
		else
			return query select * from deposits where deposits.deposit_id = 0;
		end if;
	end;
$$;

drop function if exists group_payment_plan;
create or replace function group_payment_plan (
	p_operator int,
	p_group_id int
) returns table (
	id int,
	fullname text,
	username character varying,
	account_id int,
	balance decimal(15, 2),
	raise smallint,
	discount smallint,
	lessons smallint,
	debt decimal(15, 2),
	plan decimal(15, 2),
	per_lesson decimal(15, 2),
	paid decimal(15, 2)
) language plpgsql as $$
	declare
		v_operator_id int := p_operator;
		v_group_id int := p_group_id;
	begin
		return query
		select
			p.participant_id as id,
			u.user_firstname || ' ' || u.user_lastname as fullname,
			u.user_username as username,
			a.account_id,
			a.account_balance as balance,
			q.quota_raise as raise,
			p.participant_discount as discount,
			-- lessons
			coalesce(
				t.lesson_count,
				g.group_completed_lessons
			) - p.participant_initial_lesson
			as lessons,
			(
				(
					-- lessons
					coalesce(
						t.lesson_count,
						g.group_completed_lessons
					) - p.participant_initial_lesson
				) * (
					-- per lesson
					(
						(
							g.group_price + g.group_price / 100 * coalesce(q.quota_raise, 0)
						) - g.group_price / 100 * p.participant_discount
					) / g.group_lessons
				)
			) - (
				-- paid
				coalesce(
					(
						select sum(t.transfer_amount)
						from transfers as t
						join group_payments as p on p.transfer_id = t.transfer_id
						where
							t.sender_id = a.account_id and
							p.group_id = g.group_id
					), 0
				)
			) as debt,
			(
				g.group_price + g.group_price / 100 * coalesce(q.quota_raise, 0)
			) - g.group_price / 100 * p.participant_discount
			as plan,
			(
				(
					g.group_price + g.group_price / 100 * coalesce(q.quota_raise, 0)
				) - g.group_price / 100 * p.participant_discount
			) / g.group_lessons as per_lesson,
			-- paid
			coalesce(
				(
					select sum(t.transfer_amount)
					from transfers as t
					join group_payments as p on p.transfer_id = t.transfer_id
					where
						t.sender_id = a.account_id and
						p.group_id = g.group_id
				), 0
			) as paid
		from participants as p
		left join group_transfers as t on t.participant_id = p.participant_id
		join users as u on u.user_id = p.user_id
		join accounts as a on a.user_id = p.user_id
		join groups as g on g.group_id = p.group_id
		left join quotas as q on q.quota_id = p.quota_id
		where
			g.group_completed_at is null and
			p.group_id = case when (
				select p.permission_id
				from permissions as p
				where
					p.user_id = v_operator_id and
					p.permission_action = 2
			) is not null then v_group_id else 0 end and
			p.participant_role = 2
		order by debt desc, left(u.user_firstname, 2);
	end;
$$;

drop function if exists groups;
create or replace function groups (
	p_course_id int,
	p_page int,
	p_limit int
) returns table (
	id int,
	lessons text,
	course character varying,
	debt decimal(15, 2),
	branch character varying
) language plpgsql as $$
	declare
		v_course_id int := p_course_id;
		v_page int := p_page;
		v_limit int := p_limit;
	begin
		return query
		select
			g.group_id as id,
			g.group_lessons::character varying || '/' ||
			group_completed_lessons::character varying as lessons,
			c.course_name as course,
			(
				select
					sum(
						(
							(
								-- lessons
								coalesce(
									t.lesson_count,
									sg.group_completed_lessons
								) - p.participant_initial_lesson
							) * (
								-- per lesson
								(
									(
										sg.group_price + g.group_price / 100 * coalesce(q.quota_raise, 0)
									) - sg.group_price / 100 * p.participant_discount
								) / sg.group_lessons
							)
						) - (
							-- paid
							coalesce(
								(
									select sum(t.transfer_amount)
									from transfers as t
									join group_payments as p on p.transfer_id = t.transfer_id
									where
										t.sender_id = a.account_id and
										p.group_id = sg.group_id
								), 0
							)
						)
					)
				from participants as p
				left join group_transfers as t on t.participant_id = p.participant_id
				join accounts as a on a.user_id = p.user_id
				left join groups as sg on sg.group_id = p.group_id
				left join quotas as q on q.quota_id = p.quota_id
				where
					p.participant_role = 2 and
					sg.group_id = g.group_id

			) debt,

			b.branch_name as branch
		from
			groups as g
		join
			courses as c on c.course_id = g.course_id
		join
			branches as b on b.branch_id = g.branch_id
		where
			c.course_id between
				case when v_course_id = 0 then 1 else v_course_id end and
				case when v_course_id = 0 then (
					select max(group_id)
					from groups
				) else v_course_id end and
			g.group_completed_at is null
		order by debt
		offset (v_page - 1) * v_limit limit v_limit
		;
	end;
$$;

drop function if exists login;
create or replace function login (
	p_username character varying,
	p_password character varying
) returns int language plpgsql as $$
	declare
		login_user users%rowtype;
		v_username varchar := p_username;
		v_password varchar := p_password;
	begin
		select
			u.user_id
		from
			users as u
		where
			u.user_username = v_username and
			u.user_password = crypt(v_password, u.user_password)
		into login_user;

		if login_user is null then

			return 0;

		end if;

		return login_user.user_id;

	end;
$$;

drop function if exists new_course;
create or replace function new_course (
	p_user_id int,
	p_coursename varchar
) returns table (
	id int,
	name character varying
) language plpgsql as $$
	declare
		new_course courses%rowtype;
		v_user_id int := p_user_id;
		v_coursename varchar := p_coursename;
	begin
		if
			(
				select
					p.permission_id
				from
					permissions as p
				where
					p.user_id = v_user_id and
					p.permission_action = 7
			)
			is not null
		then

			insert into courses
			(course_name) values (v_coursename)
			returning * into new_course;

			return query
				select * from courses
				where courses.course_id = new_course.course_id;
		else
			return query select * from courses where courses.course_id = 0;
		end if;
	end;
$$;

drop function if exists new_group;
create or replace function new_group (
	p_user_id int,
	p_branch_id int,
	p_price decimal(15, 2),
	p_course_id int,
	p_teacher_id int,
	p_lessons int
) returns table (
	id int
) language plpgsql as $$
	declare
		new_group groups%rowtype;
		v_branch_id int := p_branch_id;
		v_user_id int := p_user_id;
		v_price decimal := p_price;
		v_course_id int := p_course_id;
		v_teacher_id int := p_teacher_id;
		v_lessons smallint := p_lessons;
	begin
		if
			(
				select
					p.permission_id
				from
					permissions as p
				where
					p.user_id = v_user_id and
					p.permission_action = 8
			)
			is not null
		then

			insert into groups
			(branch_id, group_price, course_id, user_id, group_lessons)
			values (v_branch_id, v_price, v_course_id, p_teacher_id, v_lessons)
			returning * into new_group;

			return query
				select group_id as id from groups
				where groups.group_id = new_group.group_id;
		else
			return query select group_id as id from groups where groups.group_id = 0;
		end if;
	end;
$$;

drop function if exists new_lesson;
create or replace function new_lesson (
	p_user_id int,
	p_group_id int
) returns table (id int) language plpgsql as $$
	declare
		new_lesson lessons%rowtype;
		v_user_id int := p_user_id;
		v_group_id int := p_group_id;
	begin
		if
			(
				select
					p.permission_id
				from
					permissions as p
				where
					p.user_id = v_user_id and
					p.permission_action = 9
			)
			is not null or (
				select groups.user_id
				from groups
				where groups.group_id = v_group_id
			) = v_user_id
		then
			insert into lessons
			(lesson_started_at, group_id)
			values (current_timestamp, v_group_id)
			returning * into new_lesson;

			return query
				select lesson_id as id from lessons
				where lessons.lesson_id = new_lesson.lesson_id;
		else
			return query select lesson_id as id from lessons where lessons.lesson_id = 0;
		end if;
	end;
$$;

drop function if exists new_participant;
create or replace function new_participant (
	p_operator int,
	p_role int,
	p_il int,
	p_discount int,
	p_quota_id int,
	p_group_id int,
	p_user_id int
) returns boolean language plpgsql as $$
	declare
		v_operator int := p_operator;
		v_role int := p_role;
		v_il int := p_il;
		v_discount int := p_discount;
		v_quota_id int := p_quota_id;
		v_group_id int := p_group_id;
		v_user_id int := p_user_id;
	begin
		if
			(
				select
					p.permission_id
				from
					permissions as p
				where
					p.user_id = v_operator and
					p.permission_action = 11
			)
			is not null
		then
			insert into participants
			(participant_role, participant_initial_lesson, participant_discount, quota_id, group_id, user_id)
			values (v_role, v_il, v_discount, v_quota_id, v_group_id, v_user_id);

			return true;
		else
			return false;
		end if;
	end;
$$;

drop function if exists new_quota;
create or replace function new_quota (
	p_user_id int,
	p_group_id int,
	p_raise int
) returns table (id int) language plpgsql as $$
	declare
		new_quota quotas%rowtype;
		v_user_id int := p_user_id;
		v_group_id int := p_group_id;
		v_raise smallint := p_raise;
	begin
		if
			(
				select
					p.permission_id
				from
					permissions as p
				where
					p.user_id = v_user_id and
					p.permission_action = 10
			)
			is not null
		then
			insert into quotas
			(quota_raise, group_id)
			values (v_raise, v_group_id)
			returning * into new_quota;

			return query
				select quota_id as id from quotas
				where quotas.quota_id = new_quota.quota_id;
		else
			return query select quota_id as id from quotas where quotas.quota_id = 0;
		end if;
	end;
$$;

drop function if exists new_user;
create or replace function new_user (
	p_user_id int,
	p_username varchar,
	p_password varchar,
	p_firstname varchar,
	p_lastname varchar,
	p_gender gender,
	p_birthday date,
	p_state_id int
) returns table (
	user_id int,
	user_username character varying,
	user_password character varying,
	user_firstname character varying,
	user_lastname character varying,
	user_gender gender,
	user_birthday date,
	state_id int,
	user_is_active boolean,
	user_created_at timestamp with time zone
) language plpgsql as $$
	declare
		new_user users%rowtype;
		v_user_id int		:= p_user_id;
		v_username varchar	:= p_username;
		v_password varchar	:= p_password;
		v_firstname varchar	:= p_firstname;
		v_lastname varchar	:= p_lastname;
		v_gender gender		:= p_gender;
		v_birthday date		:= p_birthday;
		v_state_id int		:= p_state_id;
	begin
		if
			(
				select
					p.permission_id
				from
					permissions as p
				where
					p.user_id = v_user_id and
					p.permission_action = 6
			)
			is not null or (
				select count(users.user_id)
				from users
			) = 0
		then

			insert into users
			(
				user_username,
				user_password,
				user_firstname,
				user_lastname,
				user_gender,
				user_birthday,
				state_id
			) values (
				v_username,
				crypt(v_password, gen_salt('bf')),
				v_firstname,
				v_lastname,
				v_gender,
				v_birthday,
				v_state_id) returning
				*
			into new_user;

			return query
				select
					*
				from users
				where
					users.user_id = new_user.user_id;
		else
			return query select * from users where users.user_id = 0;
		end if;
	end;
$$;

drop function if exists payment;
create or replace function payment (
	operator int,
	type int,
	ref int,
	sender int,
	receiver int,
	amount decimal(15, 2)
) returns table (
	transfer_id int,
	transfer_amount decimal(15, 2),
	transfer_time timestamp with time zone,
	sender_id int,
	receiver_id int
) language plpgsql as $$
	declare
		current_transfer transfers%rowtype;
	begin
		if (
			(
				select
					u.user_id
				from
					accounts as a
				join
					users as u on u.user_id = a.user_id
				where
					a.account_id = sender
				) = operator or (
					select
						p.permission_id
					from
						permissions as p
					where
						p.user_id = operator and
						p.permission_action = 4
				) is not null
			) and (
				select
					account_balance - amount
				from
					accounts
				where
					account_id = sender
			) >= 0
		then
			insert into transfers (sender_id, receiver_id, transfer_amount)
			values (sender, receiver, amount)
			returning * into current_transfer;
			if type = 1 then
				insert into group_payments(transfer_id, group_id)
				values (current_transfer.transfer_id, ref);
			end if;
			return query select *
			from transfers
			where transfers.transfer_id = current_transfer.transfer_id;
		else
			return query select * from transfers where transfers.transfer_id = 0;
		end if;
	end;
$$;

drop function if exists set_permission;
create or replace function set_permission (
	p_operator int,
	p_user_id int,
	p_action int,
	p_val int
) returns boolean language plpgsql as $$
	declare
		new_quota quotas%rowtype;
		v_operator int := p_operator;
		v_user_id int := p_user_id;
		v_action int := p_action;
		v_val int := p_val;
	begin
		if
			(
				select
					p.permission_id
				from
					permissions as p
				where
					p.user_id = v_operator and
					p.permission_action = 0
			)
			is not null
		then

			if v_val = 1 then

				insert into permissions
				(permission_action, user_id)
				values (v_action, v_user_id);

			else

				delete from permissions
				where user_id = v_user_id and
				permission_action = v_action;

			end if;

			return true;
		else
			return false;
		end if;
	end;
$$;

